\chapter{Virtual Device API (vDev)}
\label{vdevapi}


The functions of the 'Z-Way HA' User Interface are described in the chapter \ref{vdev}. 
It  is based on so called virtual devices plus some other supporting functions
like rooms, notifications, tagging etc. The interface providing all these functions is 
called Virtual Device API (vDev).

The intention of this vDev API  is to further simplify the use of Z-Way by AJAX based 
User interface implementations and to unify the user experience across
different wireless technologies.
  
The vDev API has the following objectives and functions.

\begin{itemize}
\item Provide a list of devices that are independent of the physical devices of a 
given wireless network With this devices of different networks appear similarly.
\item Show all functions of a physical device as one virtual device each. This simplifies
the use of the data and functions provides. The Z-Wave Device API still required 
a lot of domain knowledge about the different devices, their instances, command classes, 
scales. In the vDev API every function is represented by one virtual device only 
allowing simple loops for display.
\item Provide end user related context information. This allows e.g. to define profiles, 
rooms, application etc.
\item Handle events in an user friendly way to that they can be used a notifications on a UI.
\end{itemize}

There is an online manual for syntax of the various functions that can be accessed on 

\paragraph{http://docs.zwayhomeautomation.apiary.io/}
 

\section{The virtual device}

The virtual device in the vDev API is an object that had properties and offers functions. 
Both properties, variables and functions are unified and their syntax is independent of 
the physical nature of the device they are are referred to (If there is any).

\subsection{Types and Ids}

Every Virtual device is identified by a simple string type id. For all virtual devices 
that are related to physical Z-Wave devices the device name is auto-generated by the 
ZWaveGate module following this logic:


\subsection{Virtual Device Ids}

Auto-generated devices are named after their IDs in the physical network. For Z-Wave 
devices the naming is generated using the following logic.

\paragraph{ZWayVDev\_[Node ID]:[Instance ID]:[Command Class ID]:[Scale ID]}

The Node Id is the node id of the physical device, the Instance ID is the instance id 
of the device  or '0' if there is only one instance. The command class ID refers to the 
command class the function is embedded in. The scale id is usually '0' unless the virtual
device is generated from a Z-Wave device that supports multiple sensors with different 
scales in one single command class.

\subsection{Virtual Device Type}

Virtual devices can have a certain types. The type of the device can be chosen. For a list 
of the device types current supported in the Z-Way-HA API please refer to chapter
\ref{vdev}.
 
\subsection{Access to Virtual Devices}

Virtual devices can be access both on the server side using JS modules and on the client 
side using the JSON API. On the client they are encoded into a URL style for easier 
handling  in AJAX code. A typical client side command in the vDev API looks like

\paragraph{http://YOURIP:8083/ZAutomation/api/v1/devices/ZWayVDev\_6:0:37/command/off}

'api' points to the vDev API function, 'v1' is just a constant to allow future extensions. 
The devices are referred by a name that is automatically generated from the Z-Wave 
Device API. The vDev also unifies the commands 'command' and the parameters, here 'off'.

On the server side the very same command would be encoded in a JavaScript style.

\begin{lstlisting}[caption=Access vDevs]{}

vdevId = vdev.id;

vDev = this.controller.devices.get(vdevId);

vDevList = this.controller.devices.filter(function(x) { 
	return x.get("deviceType") === "switchBinary"; }); 

vDevTypes = this.controller.devices.map(function(x) { 
	return x.get("deviceType"); }); 
\end{lstlisting}

\subsection{Virtual Device Usage / Commands}

In case the virtual device is an actor it will accept and execute a command using the 
syntax:

\paragraph{Vdev.performCommand(„name of the command“)}

The name of the accepted command should depend on the device type and can again be defined 
free of restrictions when implementing the virtual device. For auto-generated devices 
derived from Z-Wave the following commands are typically implemented.

\begin{enumerate}
\item 'update': updates a sensor value
\item 'on': turns a device on.  Only valid for binary commands
\item 'off': turns a device off. Only valid for binary commands
\item 'exact': sets the device to an exact value. This will be a temperature for 
thermostats or a percentage value of motor controls or dimmers
\end{enumerate}

\subsection{Virtual Device Usage / Values}

Virtual devices have inner values. They are called metrics. A metric can be set and get. 
Each virtual device can define its own metrics. Metrics can be level, title icon and 
other device specific values like scale (%, kWh, ...)

\begin{lstlisting}
vDev.set("metrics:...", ...);  
vDev.get("metrics:...");
\end{lstlisting}


\subsection{How to create your own virtual devices}

Virtual devices can be created using modules or Javascript code in the browser itself. 
The following code sample demonstarte how to create and delete a virtual device. For more 
information about the module concept and the creating of modules and virtual device within 
modules please refer to chapter \ref{modules}.

\subsubsection{Register device}

\begin{lstlisting}[caption=Register Device]{Name} 
        vDev = this.controller.devices.create(vDevId, {
            deviceType: "deviceType",
            metrics: {
                level: "level",
                icon: "icon from lib or url"
                title: "Default title"
            }
        }, function (command, ...) {
                // handles actions with the widget
        });  
\end{lstlisting}

\subsubsection{Unregister device}

Devices can be deleted or unregistered  using the following command:

\paragraph{this.controller.devices.remove(vDevId)}

\subsubsection{Binding to metric changes}

The metric - the inner variables of the vDev a changed by the system automatically.
In order to perform certain functions on these changes the function needs to be 
bound to the change to the vdev. The syntax for this is

\paragraph{vDev.on('change:metrics:...", function (vDev) { ... });}

Unbinding then works as one can expect:

\paragraph{vDev.off(’change:metrics:...”, function (vDev) ... )} 


\section{Notifications and events}

Notifications are a special 
kind of event to inform the user on the GUI. This means that normale events are typically
describes with numbers or ids while notifications contain a human readable message. 
The creating of events and the reaction on events is describes in chapter \ref{automation}
 
The UI can be notified on the certain events.

\paragraph{this.controller.addNotification("....severity....", "....message....", "....origin....");} 

The parameters define
\begin{itemize}
\item severity is error, info, debug; 
\item origin describes which part of the system it is about: core, module, device, battery.
\end{itemize}

The controller can act on  notifications or disable them.

\paragraph{this.controller.on('notifications.push', this.handler);}
\paragraph{this.controller.off('notifications.push', this.handler);}



 

% fs.list(),fs.stat()

 

