\chapter{The Automation Subsystem}
\label{automation}

The automation subsystem allows writing automation scripts using Javascript. It uses the 
ECMA compatible Javascript Engine described in chapter \ref{jsapi}.
All the code realizing the automation engine is written in Javascript itself and is 
available as open source for further study and modification.

The automation engine performs different actions based on events.  The actions are either 
signal commands or scripts that can add additional logic and conditions.
Events are  either generated 
from the Z-Wave network or from an outside sources such as the Internet or even from a 
user interaction is causing certain actions, either within the Z-Wave network (e.g. 
switching a light) or outside Z-Wave (e.g. sending a email). In Z-Way all automation 
is organized in so called modules. The subsequent manual will explain how these 
modules work and how to create own modules.

{\bf Attention: There is no Graphical User Interface for the automation engine at this 
moment in time. You will need a text editor such as joe, textwrangler or vi to edit 
certain files. }

\section{How to get to the automation engine}

The starting point for automation in Z-Way is called config.xml and is located in the main 
folder of Z-Way. The statement for the automation engine looks like

\begin{quote}
{\tt  
$<automation-dir>pathToAutomationCodeBase</automation-dir>$
}
\end{quote}
Assuming the automation is – like on default – in the subdirectory /automation the 
statement should look like

\begin{quote}
{\tt  
$<automation-dir>automation </automation-dir>$
}
\end{quote}

The automation folder consists of several files and subdirectories. The most important 
file of the automation is called config.json. This file contains the information 
about all automation modules and their instances. This file is automatically generated and 
should be changed without proper knowledge.


\section{The Event Bus}

All communication from and to the automation modules is handled by events. An event 
is a structure containing certain information that is exchanged using a central 
distribution place, {\bf the event bus}. This means that all modules can send events 
to the event bus and can listen to event in order to execute commands on them. All 
modules can 'see' all events but need to filter out their events of relevance.  The 
core objects of the automation are written in JS and they are available as source 
code in the sub folder 'classes':

\begin{itemize}
\item AutomationController.js: This is the main engine of the automation function
\item AutomationModule.js: the basic object for the module
\end{itemize}

The file main.js is the startup file for the automation system and it is loading the three 
classes just mentioned. The subfolder /lib contains the key JS script for the Event 
handling: eventemitter.js.

\subsection{Emitting events}

The 'Event emitter' emits events into the central event bus. The event emitter can 
be called from all modules and scripts of the automation system. The syntax is:

\begin{quote}
{\tt  
$controller.emit(eventName, args1,arg2,...argn)$
}
\end{quote}

The event name 'eventName' has to be noted in the form of 'XXX.YYY' where 'XXX' is the name 
of the event source (e.g. the name of the module issuing the event or the name of the 
module using the event) and 'YYY' is the name of the event itself.  To allow a scalable 
system it makes sense to name the events by the name of the module that is supposed to 
receive and to manage events. This simplifies the filtering of these events by the 
receiver module(s).

Certain event names are forbidden for general use because they are already used in the 
existing modules. One example are events with the name cron.XXXX that are used by the 
cron module handling all timer related events.

Every event can have a list of arguments developers can decide on. For the events used by 
preloaded modules (first and foremost the cron module) this argument structure is 
predefined. For all other modules the developer is free to decide on structure and content. 
It is also possible to have list fields and or any other structure as argument for the event

One example of an issued event can be 

\begin{quote}
{\tt  
$emit(“mymodule.testevent”,”Test”,[“event1”,”event2”])$
}
\end{quote}

\subsection{Catching (binding to) events}

The controller object, part of every module, offers a function called 'on()' to catch events. 
The 'on(name, function())' function subscribes to events of a certain name type. If not 
all  events of a certain name tag shall be processed a further filtering needs to be 
implemented  processing  the further arguments of the event. The function argument contains a reference 
to the implementation using the event to perform certain actions. The argument list of the event is 
handed over to this function in its order but need to be declared in the function call statement.

\begin{quote}
{\tt  
this.controller.on(“mymodule.testevent”, function (name,eventarray) {})
}
\end{quote}

The same way objects can unbind from events:

\begin{quote}
{\tt  
this.controller.off(“mymodule.testevent”, function (name,eventarray));
}
\end{quote}


\section{Module-Syntax}

Each module is located in a sub directory of the module-subfolder defined in the config.json file.
The name of the sub folder equals to the module name (not the instance of the module name!) 
and has at least two files:

\subsection{Module.json}

This file contains the module meta-definition used by the AutomationController. It must 
be a valid JSON object with the following fields (all of them are required):
\begin{itemize}
\item \textbf{autoload} — Boolean, defines will this module automatically instantiated during Home Automation startup.
\item \textbf{singleton} — Boolean, defines this module can be instantiated more than one time or not.
\item \textbf{defaults} — Object, default module instance settings. This object will be patched with the particular 
config object from the controller's configuration and resulting object will be passed to the initializer.
\item \textbf{actions} — Object, defines exported module instance actions. Object keys 
are the names of actions and  values are meta-definitions of exported actions used by 
AutomationController and API webserver.
\item \textbf{metrics} — Object, defines exported module metrics.
\end{itemize}
All configuration fields are required. Types of the object must be equal in every definition in every case. For instance, if module doesn't export any metric corresponding key value should be and empty object “{}”.

\subsection{index.js}
 
This script defines an automation module class which is descendant of AutomationModule base class.
During initialization the module script must define the variable '\_module' containing the particular module class.


Example of a minimal automation module:

\begin{lstlisting}[caption=Minimal Module]{MMIN}

function SampleModule (id, controller) {
SampleModule.super_.call.init(this, id, controller);

this.greeting = "Hello,World!";
}

inherits(SampleModule, AutomationModule);
_module = SampleModule;

SampleModule.prototype.init = function () {
    this.sayHello();
}

SampleModule.prototype.sayHello = function () {
    debugPrint(this.greeting);
} 

SampleModule.prototype.stop = function () {
    this.sayByeBye();
}    

\end{lstlisting} 
 
The first part of the code illustrates how to define a class function named SampleModule that calls the superclass' constructor. Its highly recommended not to do further instantiations in the constructur. Initializations should be implemented within the 'init' function.
 
The second part of the code is almost immutable for any module. It calls prototypal inheritance support routine and it fills in \_module variable.

The third part of the sample code defines module's init() method which is an 
instance initializer. This initializer must call the superclass's initializer prior to all other tasks. In the initializer module can setup it's private environment, subscribe to the events and do any other stuff.
Sometimes, whole module code can be placed withing the initializer without creation of any other class's methods. As the reference of such approach you can examine AutoOff module source code.

After the init function a module may contain other functions. The 'sayHello' function of the Sample Module shows this as example.

\section{Available Core Modules}


The automation engine already contains certain modules essential for the work of the whole system. Do now exclude these modules from the config.json and alter them only if you know exactly what you do.


\subsection{Cron, the timer module}

All time driven actions need a timer. The Z-Way automation engine implement a cron-type timer 
system as a module as well. The basic function of the cron module is

\begin{itemize}
\item It accepts registration of events that are triggered periodically
\item It allows to de-register such events. 
\end{itemize}


The registration and deregistration of events is also handled using the event mechanism. 
The cron module is listening for events with the tags 'cron.addTask' and  'cron.removeTask'. 
The first argument of these events are the name of the event fired by the cron module. The 
second argument of the 'addTask' event is an array desricing the times when this event shall be issued. It has the format: 
\begin{itemize}
\item Minute [start,stop, step] or 0-59 or null
\item Hour [start,stop, step] or 0-23 or null
\item weekDay [start,stop, step] or 0-6 or null
\item dayOfMonth [start,stop, step] or 1-31 or null
\item Month [start,stop, step] or 1-12 or null
\end{itemize}
The argument for the different time parameters has one of three formats
\begin{itemize}
\item null: the event will be fired on every minute or hour etc.
\item single value: the event will be fired when the value reaches the given value
\item array [start, stop, step]: The event will be fired between start and stop in steps.
\end{itemize}
 
 The object  
\begin{quote}
{\tt  $\{minute: null,hour: null,weekDay: null, day: null, month: null\} $   }
\end{quote} 

will fire every minute within every hour within every weekday on every day of the month every month. Another example of an event emitted towards the cron 
module for registering an timer event can be found in the Battery Polling Module:

\begin{lstlisting}[caption=Registering a Battery Polling Command]{SJSON3}
    this.controller.emit("cron.addTask", "batteryPolling.poll", {
        minute: 0,
        hour: 0,
        weekDay: this.config.launchWeekDay,
        day: null,
        month: null        
    });
\end{lstlisting}

This call will cause the cron module to emit an event at night (00:00) on a day 
that is defined in the configuration variable this.config.launchWeekDay, e.g. 0 = Sunday.

The 'cron.removeTask' only needs the name of the registered event to deregister.

\subsection{The Virtual Device Module}

This module generates virtual devices and manages them. For more information about
virtual devices and the use in a Graphical User Interface please refer to
chapter \ref {vdevapi} and \ref{vdev}.

\subsection{DeviceCollection module}

The Device Collection Module manages devices and shall not be changed.