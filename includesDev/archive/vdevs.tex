 \section{Virtual Devices API}

Virtual devices are automatically generated whenever a new phyiscla device joins one of 
the communicarion networks supported. In case the physical device gets removed the virtual 
device will disappear as well.

Virtual devices can also be generated by automation modules. For more information on this 
function please refer to the chapter xxxx

Virtual devices are organized in a flat hierarchy. This means all virtual devices are 
equal.  Virtual devices have a specific function and a name.

\subsection{Virtual Device name}

Auto-generated devices are named after their IDs in the physical network. For Z-Wave 
devices the naming is generated using the following logic.

$ZWayVDev_[Node ID]:[Instance ID]:[Command Class ID]:[Scale ID]$

Virtual devices generated by modules can have any name.

\subsection{Virtual Device Type}

Each virtual device implements a certain device type.  For autogenerated deivces the 
following device types are supported:


\begin{itemize}
\item sensorBinary
\item sensorMultilevel
\item switchBinary
\item switchMultilevel
\item switchRGBW
\item switchControl
\item toggleButton
\item thermostat
\item battery
\item camera
\item fan
\end{itemize}


For virtual device s generated by modules any device type can be choosen.
 
\subsection{Virtual Device Access}


Virtual device objects can be referred to by their name and/or by their device type. 

vdevId = vdev.id;

vDev = this.controller.devices.get(vdevId);

vDevList = this.controller.devices.filter(function(x) { 
return x.get("deviceType") === "switchBinary"; }); // filter by type

vDevTypes = this.controller.devices.map(function(x) { return x.get("deviceType"); }); 


\subsection{Virtual Device Usage / Commands}

In case the virtual device is an actor it will accept and execute a command using the syntax.


There are two ways to use a virtual device:

In case the virtual device is an actor it will accept and execute a command using the syntax.

$Vdev.performCommand(„name_of_the_command“)$.

The name of the accepted command should depend on the device type and can again be defined 
free of restrictions when implementing the virtual device. For auto-generated devices 
derived from Z-Wave the following commands are typically implemented.

\begin{enumerate}
\item 'update': updates a sensor value
\item 'on': turns a device on.  Only valid for binary commands
\item 'off': turns a device off. Only valid for binary commands
\item 'exact': sets the device to an exact value. This will be a temperature for 
thermostats or a percentage value of motor controls or dimmers
\end{enumerate}

\subsection{Virtual Device Usage / Values}

Virtual devices have inner values. They are called metrics. A metric can be set and get. 
Metrics can be level, title icon and other device specific values like scale (%, kWh, ...)


\begin{lstlisting}
vDev.set("metrics:...", ...);  
vDev.get("metrics:...");
\end{lstlisting}

\subsection{More on REST API}

Locations, Profiles, Notifications
http://docs.zwayhomeautomation.apiary.io/
  
\subsection{How to create your own virtual devices}


Virtual devices can be created using modules or Javascript code in the browser itself. 
The following code sample demonstarte how to create and delete a virtual device. For more 
information about the module concept and the creating of modules and virtual device within 
modules please refer to chapter \ref{modules}.

\subsubsection{Register device}

\begin{lstlisting}[caption=Register Device]{Name} 
        vDev = this.controller.devices.create(vDevId, {
            deviceType: "deviceType",
            metrics: {
                level: "level",
                icon: "icon from lib or url"
                title: "Default title"
            }
        }, function (command, ...) {
                // handles actions with the widget
        });  
\end{lstlisting}

\subsubsection{Unregister device}

this.controller.devices.remove(vDevId);

 
\subsubsection{Catch device updates}

vDev.on('change:metrics:...", function (vDev) { ... });


 
\subsubsection{Notifications}

controller.addNotification("....severity....", "....message....", "....origin...."); // severity is error, info, debug; origin describes which part of the system it is about: core, module, device, battery.
controller.on("notification.pushs.push", function({timestamp, severity, message, type}) {....}); // catch notification

\subsubsection{Global namespace}
Module and vdev params can refer to glabal lists shared by different modules. This allows 
to use in module configuraion lists of devices, scenes, ... and other objects that depends 
on configuration of other modules.

\subsubsection{Bind to events}

controller.on("....", function(....eventObject....) {});


\subsubsection{Unbind from events}

controller.off("....", function(....eventObject....) {});
